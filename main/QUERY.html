<html>
<head>
<title>The XMLD-SQL Query Specification</title>
</head>	
<body>
<pre><xmp>
	          The XMLD-SQL Query Specification
		  --------------------------------
Author(s):
Khalid Al-Kary

Revision: 1.3
------------------------------------------------------------------		  
Introduction:
-------------

As you may have already known, the XMLD-SQL query specification
aims at being as SQL-compliant as possible while remaining as 
XML-capable as possible. this may seem to be hard to do at first
but I could get to some useful ideas that would make it possible,
However, I think some of SQL's features may not be implementable,
but I also believe that these will not be needed in a XML-based
database.

The idea of being SQL-compliant doesn't mean making current SQL
applications be portable to the OpenXMLD with no touches, but
in a greater extent means making the current SQL developers
avoid any needs to learn something new (except for XML itself),
however, the more SQL-compliance XMLD-SQL offers, the better
it's.

Note: readers of this document must have a SQL background.
it's not a documentation--it's a temproary implementation
guide.

Expressions:
------------
An expression can be:
 
 [*] A column name.
 [*] A function call.
 [*] A mathematical expression.
 [*] A sequence of characters.
 [*[ A wildcard.

Note: a column in XML is generally an XML element's attribute,
in addition to these two special values:
  
 [*] "(text)" is the text of an element.
 [*] "(tagname)" is the name of an element's tag.

Note that accodring to XML an attribute name can't have a bracket in
it -- so (text) and (tagname) never conflict with normal attribute
names.

A wildcard can be:

 [*] * -- All columns
 [*] @ -- All attributes (All columns execluding "(text)" and "(tagname)")
 
According to that specification, the following are valid XMLD-SQL 
expressions:
  
name
age
STRCAT(UCASE((text)),UCASE(age))
STRLEN(name)+5
SIN(5+6)
COUNT(*)
age-1
"my name is a name"

Note: there are two types of functions--aggregate and scalar. 
Scalar functions do their processing in a per-row manner they
need nothing but values extracted from the current row in the
table:

SIN(angle)

On the other hand, aggregate functions need to be given the
ability to process a set of rows in a file in order to properly
get their value:

COUNT(name) -- Number of rows that have non-NULL values of the
column named "name"

As you can see in the example, this function needs to look at
the whole table to know the number of rows that have non-NULL 
values of the "name" column. Aggregate functions are not
allowed in some contexts, which are going to be mentioned
individually later in this document.

Expression lists:
-----------------
An expression list is a group of expressions separated by
commas:

<expression>, <expression>, <expression> ...

Those are used in places like the select statement:

select age, name, gender from "persons.xml"

A XML file is not a flat table:
-------------------------------
XML is multi-levelled:

<root>
 <level1>
  <level2/>
 </level1>
</root>

This point must need special care within XMLD-SQL in 
order to achieve full XML proccessing capability. 
Consider this SQL query:

select age, name, gender from persons

this should get age, name and gender column values
from all the single-level table, that is meaningful in
such context, but for XML this should normally mean trial
to retrieve age, name and gender attributes from all the
levels of the document--this is probably not the wanted 
behaviour. XMLD-SQL offers a per-level specification
of the columns to be retrieved/updated/checked/whatever
using the ":" operator, which is going to be further
explained later:

Level-sensitive expression lists:
---------------------------------
Here's an example:

name, age, gender:type, color, size

Because XML is multi-levelled, the need for level-sensitive
expression lists arises, that is--this expression list when
the current level is 1 (root) evaluates to:

name, age, gender

And when the current level is 2, it evaluates to:

type, color, size

This one can be used in a XML-SQL specific query:

select name, age, gender:type, color, size from "persons.xml"

Void expression lists:
----------------------
Recalling level-sensitive expression lists:

name, age, gender:type, color, size

As you can see, each level in that expression does two tasks--
preserving the level order and specifying the expressions
used for that level. In some cases you may need to do only the
first task--preserving the level order--in order to specify
the expressions used for a deeper level.

That is, you will need something like this:

:type, color, size

So, if the current level is one, this expression is supposed
to evaluate to "nothing" and if it was 2 it evaluates to
type, color, size. However, the empty string can't be easily
tracked down by a modest query parser, and doesn't make the
meaning be apparent enough, therefore, usage of the special
'!' character is to do that purpose. thus, the correct form
of the expression list above is:

!:type, color, size

Note that it can go between two levels:

name, age, gender:!:vendor

Conditionals:
----------------
A conditional statement:

expression <condition> expression

The condition itself can be:

 [*] Equal "="
 [*] Greater than ">"
 [*] Smaller than "<"
 [*] Greater than or equal ">="
 [*] Smaller than or equal "<="
 [*] Not equal "<>"
 [*] LIKE
 [*] BETWEEN
 [*] NOT BETWEEN

Note: neither the left nor the right expressions can be wildcards.
Wildcards are normally useful for retrieval operations. 

Conditional negation:
---------------------
To negate a condition:

NOT <expression> <condition> <expression>

Conditional grouping:
---------------------
Grouping of conditionals can be achieved using AND, OR and brackets, such as:

age > 150 AND (gender = "male" OR haircolor = "yellow")

Level-sensitive conditionals:
-----------------------------
As the name implies those evaluate differently according to the current 
level in the document:

age = 50 AND gender = "male":type = "shoes" OR size = 10

Void conditionals are used for the same purpose of void expression lists, they 
always evaluate to true, that is--keeping the level order and do nothing 
themselves.

!:type="shoes" OR size=10

Assignments:
------------

<column name> = <expression>

Means: Assign <expression>'s value to the column named <column name>.

Note: the right hand expression must not be an aggregate one.

Assignment lists:
-----------------
A group of assignments grouped by commas:

name = "bb52", age = "20"
bugs_status = "too many"

Level-sensitive assignements:
-----------------------------

name = "b552", age="20":!:vendor="worst one"

And yes! there are void assignment lists.

Handling infinite levelling:
----------------------------
As previously mentioned, the ":" character is used to maintain 
level-sensitivity in various contexts, however, in many situations
the number of levels in the XML tree is greater than those which
are mentioned in a level-sensitive language construct. Actually
in some situations, the number of levels can't even be known!

There are two ways to take when it comes to levels larger than
the mentioned in a language construct:

[1] Ignore them.
[2] Apply semantics of the last mentioned level to them.

Ignoring is the default behaviour, that is:

name, age, gender

will evaluate to nothing in level 2.

In XMLD-SQL, the '~' prefix operator is used to apply the 
semantics of the language construct just after it to
all the deeper levels, that is:

~name, age, gender

will evaluate to:

name, age, gender

in level 2 and above.

Note: the '~' operator can only be used in the last mentioned
level in a level-sensitive language construct.

Note: the '~' operator can appear before a void condition/expression
/assignment list ('!'), but it has a real meaning only in case of 
condition lists:

Condition lists: Evaluate to true all the deeper levels.
Assignment lists: Don't assign anything for all the deeper levels
(that's the default behaviour).
Expression lists: Don't retrieve anything from deeper levels
(that is also the default behaviour).

Table name representation:
--------------------------

XML files are not database tables, they are files that have extensions
that contain dots, the reason for which these files' names when mentioned
inside a query have to be quoted for the dots and other special characters
not to be mixed with other uses of them inside the query:

"subdirectory1/file1.xml"
"file2.xml"
"sub2/file3.xml"
"/file4.xml"

File lists:
-----------
In SQL, this is valid:

<table name>, <table name>

and it denotes usage of both of the given table names to
do something.

In XMLD-SQL, this is also valid, with respect to the table name representation
method mentioned above:

"file4.xml", "dir1/file2.xml"

Database name representation:
-----------------------------
XMLD-SQL uses native file system "folders" to represent databases, allowing
for useful ideas like database nesting. When a database name is to be used
inside a query, it has to be quoted for the same reason of file name 
quoting:

"/db1"
"db2"

Note: '/' at the beginning normally means the document root of the 
server and not the filesystem root.

File-specific column names:
---------------------------
According to the formerly mentioned "File lists", more than one file can 
be used in the same query, the case in which an association of column names 
to a particular file is needed. Here's the syntax:

<file name>.<column name>

Means: <column name> of the file named <file name>.

Examples:

"file4.xml".name

This association of column names to files can be used inside expressions of any
kind to refer to that column's value with respect to the given file name.

If there wasn't multiple files in a query it ofcourse is optional to associate
the column name to a particular file. If there was multiple files in a query
and one of the column names in it has no file association, the column is
automatically associated to the first file mentioned in the query's file list.

The USE clause:
---------------
The USE clause changes the current path to a particular path:

USE <path>

Note: XMLD-SQL is case-insensitive.

The WHERE clause:
-----------------

The WHERE clause in XMLD-SQL is followed by a level-sensitive condition list,
this level-sensitive condition list has two important things to mention.

[*] That it must not contain aggregate function calls.
[*] The WHERE statement when one level fails to match the level-sensitive 
condition list specification doesn't check the levels nested by it, that is:

select name, age:color, size from "persons.xml" where age = "11":size > 40

If in one of level 1 elements age didn't equal 11, level 2 elements which are
nested by that element are not checked against "size > 40" and therefore 
never used to retrieve data (color and size).

Exception: if the last level in a condition list was marked as cross-level
(i.e perceded by ~) this rule doesn't apply, all the elements in levels checked 
against that last cross-level condition list are checked independently.

The SELECT clause:
------------------

SELECT <level-sensitive expression list> FROM <file list>
SELECT <level-sensitive expression list> FROM <file list> WHERE <level-sensitive condition list>

The UPDATE clause:
------------------

UPDATE <file list> SET <level-sensitive assignment list>
UPDATE <file list> SET <level-sensitive assignment list>  WHERE <level-sensiitve condition list>

The DELETE clause:
------------------

DELETE FROM <file list>
DELETE FROM <file list> WHERE <level-sensitive condition list>
DELETE * FROM <file list>

The INSERT clause:
------------------

INSERT INTO <file name> [( <level-sensitive column names list> )] VALUES ( <level-sensitive 
expression list> )

INSERT INTO <file name> [( <level-sensitive column names list> )] VALUES 
( <level-sensitive expression list> ) WHERE <level-sensitive condition list>

-- to be continued
</xmp></pre>
</body>
</html>

<html>
<head>
<title>The XMLD-SQL proposed Query Specification</title>
</head>	
<body>
<pre><xmp>
The XMLD-SQL Proposed Query Specification: (By Khalid Al-Kary)
------------------------------------------

Introduction:
-------------

As you may have already known, the XMLD-SQL query specification
aims at being as SQL-compliant as possible while remaining as 
XML-capable as possible. this may seem to be hard to do at first
but I could get to some useful ideas that would make it possible,
However, I think some of SQL's features may not be implementable,
but I also believe that these will not be needed in a XML-based
database.

The idea of being SQL-compliant doesn't mean making current SQL
applications be portable to the OpenXMLD with no touches, but
in a greater extent means making the current SQL developers
avoid any needs to learn something new (except for XML itself),
however, the more SQL-compliance XMLD-SQL offers, the better
it's.

Scalar Expressions (sc_expr):
----------------------------
A scalar expression can be one of the following:
 
 [*] A column name.
 [*] A scalar function call.
 [*] A mathematical expression.
 [*] A sequence of characters.

Note: a column in XML is generally an XML element's attribute,
in addition to these two special cases:
  
 [*] "(text)" is the text of an element.
 [*] "(tagname)" is the name of an element's tag.

According to that, the following are valid XMLD-SQL expressions:
  
name
age
STRCAT(UCASE((text)),UCASE(age))
STRLEN(name)+5
age-1
"my name is a name"

Aggregate Expression (agr_expr):
--------------------------------
An aggregate expression is identically a scalar expression
with the exception that it can contain aggregate functions.
 
From my understanding, an aggregate function is a function whose
value depends on more than one element that the XML processor 
needs to go through all the elements to get its value, and it has 
one value for all of the elements.

An example of an aggregate function call:

COUNT(*) -- counts the number of rows.
COUNT(age) -- counts the number of rows that have non-NULL values 
for the age column.

Expression list:
----------------
An expression list is a group of expressions separated by
commas:

expr1, expr2, expr3 ...

You can expect these two types of expression lists:
 
 [*] A scalar expression list: which contains only scalar 
 expressions. (namely sc_expr_list)
 [*] An aggregate expression list: which can contain both scalar
 and aggregate expressions. (namely agr_expr_list)

Note: a single expression is still considered an expression list.

The Conditional:
----------------
A conditional statement:

[1] expr <condition> expr
[2] ! (void condition)

Ofcourse, expr can be either scalar or aggregate, in which cases
the conditional would be called a scalar conditional (sc_cond) 
or an aggregate conditional (agr_cond) respectively.

condition can be:

 [*] equal '='
 [*] greater than '>'
 [*] smaller than '<'
 [*] greater than or equal '>='
 [*] smaller than or equal '<='
 [*] LIKE
 [*] BETWEEN
 [*] NOT BETWEEN

A void condition (represented by the single exclamation mark '!') is
used to maintain an always true condition. The use of that one is 
to be discussed later (in Multi-level conditionals).

Conditional Negation:
---------------------
To negate a condition:

 NOT expr <condition> expr

this is after all treated as a condition (sc_cond and agr_cond)

Conditional Grouping:
---------------------
A group of conditionals grouped by AND, OR and brackets, such as:

cond1 AND NOT ((cond1 OR cond2) AND cond3)
cond5

Note: a single conditional is still considered a group.
Hint: sc_cond_group, agr_cond_group ?

Multi-level Conditionals:
-------------------------
XML is multi-levelled:

<root>
 <level1>
  <level2>
 </level1>
</root>

For that reason Multi-level conditionals are required, which are
infact a collection of conditional groups (either scalar or ag-
gregate) separated by colons--each condition stands for one 
level in the XML tree corresponding to its index in the 
Multi-level conditional:

Scalar Multi-level Conditional (sc_cond_level):

sc_cond_group [: sc_cond_group [: sc_cond_group ...]]

Aggregate Multi-level Conditional (agr_cond_level):

agr_cond_group [: agr_cond_group [: agr_cond_group ...]]

Example:

Scalar: 
(tagname)="people" AND country="country1" : LCASE(name)="myname"

Aggregate:
count(*)=5 : count(name)=7

Usage of void conditions: You may need to define a condition for
a particular level while keeping the level before it be selected
unconditionally. In such case you will need to use the void condition 
(!) to keep the order while maintaining the semantic of an "Always true" 
condition.

Assignment:
-----------
Syntax:

<column_name> = sc_expr (scalar assignment--sc_assign)
<column_name> = agr_expr (aggregate assignment--agr_assign)

Assignment groups:
------------------
Syntax:

sc_assign[, sc_assign[, sc_assign]] (scalar assignment group--
sc_assign_group)

Such as:

name = "bb52", age = "20"
bugs_status = "too many"

An aggregate assignment group is the one that contains at least
one aggregate assignment. Aggregate assignments and aggregate 
assignment groups are currently unusable, just written for com-
pleteness and for there might be a use for them at a later point.

The FILE string:
----------------
Is a special case of an expression, that can only contain a quoted
sequence of characters that represents a XML file name relative
to the current directory or absolute starting from the server root.

"subdirectory1/file1.xml"
"file2.xml"
"sub2/file3.xml"
"/file4.xml"

The DIR string:
---------------
Is a special case of an expression, that can only contain a quoted
sequence of characters that represents a path either relative to the
current directory, or absolute starting from the server's root.

"/db1"
"db2"

The USE clause:
---------------
The USE clause changes the current path to DIR.

USE DIR

The SELECT clause:
------------------

SELECT agr_expr_list FROM FILE
SELECT agr_expr_list FROM FILE WHERE sc_cond_level

The UPDATE clause:
------------------

UPDATE FILE SET sc_assign_group
UPDATE FILE SET sc_assign_group WHERE sc_cond_level

The DELETE clause:
------------------

DELETE FROM FILE
DELETE FROM FILE WHERE sc_cond_level
DELETE * FROM FILE

The INSERT clause:
------------------

INSERT INTO FILE [(<column_name>[, <column_name> [...]])]
VALUES (sc_expr[, sc_expr [...]])

INSERT INTO FILE [(<column_name>[, <column_name> [...]])]
VALUES (sc_expr[, sc_expr [...]]) WHERE sc_cond_level

-- to be continued
</xmp></pre>
</body>
</html>
